### DOM_BOM
```
    браузер скачивает по сети текст, создает из него дом структуры которые затем отрисовываются.

    Объектная модель браузера (BOM)
      (BOM) – это объекты для работы с чем угодно, кроме документа. (navigator, location)

    document.addEventListener('DOMContentLoaded', ...); - когда построен дом страници, не ждет картинок, CSS

    псевдоэлементы - задаются и изменяются только через каскад css
```
### Объектная модель документа (DOM)
      Во время загрузки браузер читает документ и тут же строит из него DOM,
      по мере получения информации достраивая новые и новые узлы, и тут же отображая их.
      Когда браузер читает HTML и создаёт DOM-модель, то он создаёт свойства для всех стандартных атрибутов.
      DOM-модель – это внутреннее представление HTML-страницы в виде DOM-узлов.
      HTML-атрибуты и DOM-свойства обычно, но не всегда соответствуют друг другу.
      Для нестандартных атрибутов DOM-свойство не создаётся.
      Стандартные свойства и атрибуты синхронизируются: установка атрибута автоматически ставит свойство DOM.
        Некоторые свойства синхронизируются в обе стороны.  Чаще синхронизация – односторонняя: свойство зависит от атрибута, но не наоборот.
      Все элементы страницы, включая теги, текст, комментарии, являются узлами DOM.
      DOM-узлы – обычные JavaScript-объекты. Их классы заданы в прототипном стиле.
      различие между DOM-узлами – разные узлы являются объектами различных классов.
      Нестандартные (пользовательские) свойства и методы видны только в JavaScript не влияют на отображение тега.

      --для более короткого и понятного кода старайтесь везде использовать свойства, а атрибуты – только там, где это действительно нужно.

        1.Когда нужно кросс-браузерно получить нестандартный HTML-атрибут.
        2.Когда нужно получить «оригинальное значение» стандартного HTML-атрибута, например, <input value="...">.
        3.Когда нужно получить список всех атрибутов, включая пользовательские. Для этого используется коллекция attributes.

    12 типов узлов, но на практике мы работаем с четырьмя из них:
      1.Документ – точка входа в DOM.
        2.Элементы – основные строительные блоки, Теги образуют узлы-элементы (element node).                 ELEMENT_NODE = 1;
        3.Текстовые узлы – содержат, собственно, текст.                                                       TEXT_NODE = 3;
      4.Комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна из JS.   COMMENT_NODE = 8;


### доступ к атрибутам

      Эти методы работают со значением, которое находится в HTML.

      elem.hasAttribute(name) – проверяет наличие атрибута
      elem.getAttribute(name) – получает значение атрибута, input.value = содержит введенное значение
      elem.setAttribute(name, value) – устанавливает атрибут
      elem.removeAttribute(name) – удаляет атрибут
      elem.attributes.attr.value или (elem.attributes[0]) - содержит псевдо-массив объектов типа Attr

      Атрибуту "class" соответствует свойство className.

      elem.classList – псевдо-массив для работы с классами. (живая коллекция, содержит ссылку на нее);
      elem.classList.contains("class") – возвращает true/false, в зависимости от того, есть ли у элемента класс class.
      elem.classList.add/remove("class") – добавляет/удаляет класс class
      elem.classList.toggle("class") – если класса class нет, добавляет его, если есть – удаляет.


      Атрибуты в отличии от свойств - Всегда являются строками, Их имя нечувствительно к регистру (ведь это HTML), Видны в innerHTML

      -- Не стандарьные атрибуты
        Атрибуты, название которых начинается с data-, можно прочитать через dataset.
        <div id="elem" data-about="Elephant">
          elem.dataset.about - получить/изменить значение атрибута через свойство.

        <div class="order" order-state="new">
          div.setAttribute('order-state', 'canceled');
          значение атрибута – произвольная строка, значение класса – это «есть» или «нет», поэтому естественно,
          что атрибуты «мощнее» и бывают удобнее классов как в JS так и в CSS.

### свойства узлов

      nodeType
          Тип узла.
      tagName
          (для элементов) тег.
      nodeName
          для не-элементов обычно содержит строку с типом узла, для элементов равно tagName.
      --содержимое элементов
      innerHTML
          HTML-содержимое элемента в виде строки. В innerHTML можно и читать и писать.(Если в innerHTML есть тег script – он не будет выполнен.)
      outerHTML
          создает новый элемент, заменит след children, возвращает элем след за ним.

      --содержимое текстовых узлов
      data/(nodeValue не используем)
          для всех узлов кроме элементов, равно содержимому узла, доступно на чтение и запись.
      textContent
          возвращает конкатенацию всех текстовых узлов внутри elem, возможность записать текст в элемент, причём именно как текст!
          (нестандартное свойство innerText, не используем).
      hidden
          видим или невидим узел, атрибут и свойство для этого: hidden.  в CSS, свойства display или visibility.

          elem.style.dispaly = 'none'; //удаляется из дерева рендеренга, не сохраняет геометрию (размеры)
          elem.style.visibility = 'hidden'; //находдится в дереве рендеренга, сохраняет геометрию (размеры)

          отобразить elem.style.dispaly = '';

          через css elem.classList.toggle('hidden');

          удалить из док document.body.removeChild(elem)


      При генерации DOM браузер самостоятельно орабатывает ошибки в документе, закрывает теги и так далее.



### Навигация по узлам

        <HTML> = document.documentElement (ссылка на элемент)
        <HEAD> = document.head (в соврем браузерах)
        <BODY> = document.body (ссылка на элемент)
        Нельзя получить доступ к элементу, которого еще не существует в момент выполнения скрипта.
        В частности, если скрипт находится в <head>, то в нём недоступен document.body.
        В мире DOM в качестве значения, обозначающего «нет такого элемента» или «узел не найден», используется null.

        Дочерние элементы (или дети) – элементы, которые лежат непосредственно внутри данного. Например, внутри <HTML> обычно лежат <HEAD> и <BODY>.

        Потомки – все элементы, которые лежат внутри данного, вместе с их детьми, детьми их детей и так далее. То есть, всё поддерево DOM.


    -- навигация по всем узлам (узлам-элементам текстовым узлы и узлам-комментариям)
        в childNodes сосуществуют текстовые узлы, узлы-элементы,/ узлы-комментарии
        elem.childNodes - (псевдомассив как arguments) все дочерние элементы body.
        elem.hasChildNodes - наличие дочерних элементов.
        elem.firstChild - первый дочерний элемент body.      elem.childNodes[0] === elem.firstChild
        eles.lastChild - последний дочерний элемент body.    elem.childNodes[elem.childNodes.length - 1] === elem.lastChild
        elem.previousSibling, nextSibling - доступ к элементам слева и справа данного
        elem.parentNode - доступ к родителю.

    -- Навигация только по элементам
        elem.children – только дочерние узлы-элементы, то есть соответствующие тегам.
        elem.firstElementChild, lastElementChild – соответственно, первый и последний дети-элементы.
        elem.previousElementSibling, nextElementSibling – соседи-элементы.
        elem.parentElement – родитель-элемент.

        elem.children[0] === elem.firstElementChild
        elem.children[elem.children.length - 1] === elem.lastElementChild

    отличие parentNode от parentElementparentNode
      alert( document.documentElement.parentNode ); // document
      alert( document.documentElement.parentElement ); // null

    -- навигация по формам, таблицам.
        document.forms.myform - доступ к форме по имени
        document.forms.mytable.elements.myinput - доступ к полю по имени
        table.rows - псевдомассив строк
        table.rows[0].cells - псевдомассив ячеек



### поиск элементов (Есть 6 основных методов поиска элементов DOM)

        в 95% ситуаций достаточно querySelector/querySelectorAll. Хотя более специализированные методы getElement* работают чуть быстрее

        --Внутреннее устройство поисковых методов

        getElementsBy* – живые запросы! При изменении документа – изменяется и результат запроса.
        поиск выполняется только при обращении к элементам коллекции или к её длине.

        elem.querySelector/All- Последние результаты поиска сохраняются в кеше. Но это до тех пор, пока документ как-нибудь не изменится.

        --поиск только в контексте document (возвращает только элементы)
          document.getElementById("list") или через переменную list, getElementById
            (живая колекция)document.getElementsByName(name) - возвращает список элементов с атрибутом name.(используется редко)

        живая колекция - хранит живой поисковый запрос, который выполняется при обращении к элементам колекции.
          при изменении документа, поиск структура сбрасывается, если в этот узеле есть изменения.(колекция не держит док в памяти)

        --поиск внутри элементов (возвращает только элементы)
          (живая колекция)elem.getElementsByTagName(tag) - возвращает список элементов, ('*' вместо тега, получить всех потомков)
          (живая колекция)elem.getElementsByClassName(className) возвращает коллекцию элементов с классом className (даже если у него несколько классов)
          elem.querySelectorAll(css) возвращает все элементы внутри elem, удовлетворяющие CSS-селектору css.(делает полный обход документа)
          (хранит старую колекцию после изменения или удаления из дом)
          elem.querySelector(css) возвращает не все, а только первый элемент, соответствующий CSS-селектору css.
          elem.closest(css) для поиска ближайшего родителя. Сам элемент тоже включается в поиск.

        --при переборе элементов
        elem.matches(css) проверяет, удовлетворяет ли elem селектору css, возвращает true либо false.

        -- Xpath (язык запросов) обычно используется в XML. также HTML, кроме IE<9 (используется редко)


### Методы для создания узлов:

        document.createElement(tag) – создает элемент
        document.createTextNode(value) – создает текстовый узел
        elem.cloneNode(deep) – клонирует элемент, если deep == true, то со всеми потомками, если false – без потомков.

        Вставка и удаление узлов:
        при вставке узла происходят разные внутренние события и обновления внутренних структур данных, скрытые от наших глаз.

        parent.appendChild(elem)
        parent.insertBefore(elem, nextSibling) nextSibling - перед кем вставить
        parent.removeChild(elem)
        parent.replaceChild(newElem, elem)
        Все эти методы возвращают elem.

        innerHTML += удаляет все содержимое, ставит новое (изменяя внутренние структуры).
        insertAdjacentHTML позволяет вставлять произвольный HTML в любое место документа, в том числе и между узлами!
        elem.insertAdjacentElement(where, newElem) – вставляет в произвольное место не строку HTML, а элемент newElem.
        elem.insertAdjacentText(where, text) – создаёт текстовый узел из строки text и вставляет его в указанное место относительно elem.

        node.append(...nodes) – вставляет nodes в конец node,
        node.prepend(...nodes) – вставляет nodes в начало node,
        node.after(...nodes) – вставляет nodes после узла node,
        node.before(...nodes) – вставляет nodes перед узлом node,
        node.replaceWith(...nodes) – вставляет nodes вместо node.


###  <script> document.write('') </script> используется там где не подходят методы дом

        <script> document.write('<script> document.write("<li>asd</li>") <\/script>') </script>

        альтернатива

        // браузер загрузит скрипт, и выполнит его, (асинхр)не блокирует отрисовку страници в отличии от document.write
        var script = document.createElement('script');
          script.src = '';
          document.body.appendChild('script');


        Методы document.write пишут напрямую в текст в документ, до создания DOM,
        поэтому они могут записать в документ все, что угодно, любые стили и незакрытые теги.
        Метод document.write вставляет любой текст на страницу «как есть»
        Запуск document.write после загрузки приведёт к очистке документа.

        document.close();

        Загрузка динамического скрипта блокирует отрисовку всей страниц, и будет ждать его загрузки.
        желательно подключать внешние скрипты, используя вставку скрипта через DOM или async/defer.

###  навигация по элементам в консоли

        $0 - теккущий элемент, выбранный во вкладке Elements
        $1 - предыдущий выбранный эл, и так далее.
        inspect($1) - переходит на элемент.
        $$("div.my") – ищет все элементы в DOM по данному CSS-селектору
        $("div.my") – ищет первый элемент в DOM по данному CSS-селектору.


###  стили элемента
        Свойство style содержит лишь тот стиль, который указан в атрибуте элемента, без учёта каскада CSS.

        element.style возвращает объект, который дает доступ к стилю элемента на чтение и запись.
          Чтобы сбросить elem.style.width="". При сбросе свойства style стиль будет взят из CSS.
          Свойство style нужно использовать лишь там, где классы не подходят, например
            если точное значение цвета/отступа/высоты вычисляется в JavaScript.

        element.style.cssText = "..." позволяет поставить стиль целиком в виде строки.(осуществляет полную перезапись style.)

        getComputedStyle(elem) - свойство стиля с учётом CSS-каскада и браузерных стилей по умолчанию
          При обращении к сокращенному: padding, margin, border – правильный результат не гарантируется.
          нужно указать точное свойство. Например: paddingLeft, marginTop, borderLeftWidth.
        В IE8- нет getComputedStyle, но у элементов есть свойство currentStyle

        Вычисленное (computed) и окончательное (resolved) значения
          В CSS есть две концепции:

          Вычисленное (computed) значение – это то, которое получено после применения всех правил CSS и CSS-наследования.
              Например, width: auto или font-size: 125%.
          Окончательное (resolved) значение – непосредственно применяемое к элементу.
              При этом все размеры приводятся к пикселям, например width: 212px или font-size: 16px. В некоторых браузерах пиксели могут быть дробными.
          Когда-то getComputedStyle

###  проверка на вложеность, порядок расположения узлов
        nodeA.contains(nodeB) - является ли один узел предком другого.
        nodeA.compareDocumentPosition(nodeB); - порядок расположения узлов.
        Для IE8 нужен полифилл для compareDocumentPosition.


###  iframe
        в каждом iframe свой независимый документ
        если фреймы на разных доменах, (как независимые окна браузера)мы не можем между ними общяться.

        iframe.contentWindow.document - у каждого окна свой документ.

        X-Frame-Options - запрет показывать в iframe. (DANY - всем) (SAMEORIGIN - разрешает если страница на том же домене)

###  Полифиллы
        «Полифилл» (англ. polyfill) – это библиотека, которая добавляет в старые браузеры поддержку возможностей,
            которые в современных браузерах являются встроенными.

          Создаётся элемент, который его, в теории, должен поддерживать.
          Соответствующее свойство сравнивается с undefined.
          Если его нет – модифицируется прототип, обычно это Element.prototype – в него дописываются новые геттеры(Object.defineProperty) и функции.

        Полифиллы хороши тем, что мы просто подключаем их и используем везде современный DOM/JS,
        а когда старые браузеры окончательно отомрут – просто выкинем полифилл, без изменения кода.


### живая коллекция пример
        <ul id="menu">
          <li>Главная страница</li>
          <li>Форум</li>
          <li>Магазин</li>
        </ul>

        <script>
          var lis1 = document.body.getElementsByTagName('li');

          var menu = document.getElementById('menu');
          var lis2 = menu.getElementsByTagName('li');

          console.log(lis1);
          console.log(lis2);

          document.body.innerHTML = '';

          console.log('после удаления');
          console.log(lis1);
          console.log(lis2);
        </script>



