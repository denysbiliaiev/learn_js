learn.javascript

this - тянет c обьекта с которым  была вызвана через точку или bind
фунции стрелки тянут this с замыкания как и обыч переменные

функция declaration видна только в своем блоке, 
class виден только в текущем блоке и только в коде, который находится ниже объявления

При запуске функции создаётся новый объект с переменными LexicalEnvironment(объект переменных). 
Он получает ссылку на внешний объект переменных из [[Scope]](скрытое свойство функции).

Значение this называется контекстом вызова и будет определено в момент вызова функции.

Контекст this никак не привязан к функции, даже если она создана в объявлении объекта. Чтобы this передался, нужно вызвать функцию именно через точку (или квадратные скобки).

function sum(a) {
  var currentSum = a;
  function f(b) {
    console.log(b);
    currentSum += b;
    return f;
  }
  f.toString = function() {
    return currentSum;
  };
  return f;
}
console.log(sum(1)(3)); 
1 раз записывает в замыкание currentSum = 1 и возвращает ccылку на f,
2 раз вызывает f c параметром 3 и возращает также f   


function Animal(name) {
  // this = {};
  // в this пишем свойства, методы
  this.name = name;
  // return this;
}
при создании обьекта через конструктор
вызов return с объектом вернёт объект, 
а с чем угодно, кроме объекта — возвратит, как обычно, this.
конструктор
Те функции и данные, которые должны быть доступны для внешнего кода, мы пишем в this. а вспомогательные, которые нужны только внутри самого объекта, сохраняем в локальной области видимости var.


(user.name == "Вася" ? user.hi : user.bye)(); // undefined
здесь this , будет undefined


Литерал объекта – это заключенный в фигурные скобки список свойств (пар «имя–значение»), разделенных запятыми.
var empty = {}; // литерал обьекта
var calculator = {
    operand1: 1,
    operand2: 1,
    compute: function( ) {
        this.result = this.operand1 + this.operand2;
    }
};

Перечисление свойств
for(var name in obj) names += name + "\n";
    alert(names);

Проверка существования свойств
if ("x" in o) o.x = 1;

обращении к несуществующему свойству возвращается значение  undefined
if (o.x !== undefined) o.x = 1;

Если свойство doSomething существует и не содержит значение null или undefined 
if (o.doSomething) o.doSomething();

Узнать тип обьекта. Всегда вызывается метод по умолчанию toString() 
Object.prototype.toString.apply(o); 

Доступ к свойствам объекта 
object.property - имя свойства представляет собой идентификатор
object["property"] - имя свойства представляет собой строку
customer["address" + i] + '\n';

Функции
function sqrt(x) { return x*x; };
o.square = function(x) { return x*x; }; // функциональный литерал
var tensquared = (function(x) {return x*x;})(10); // Определить и вызывать

(function( ) { // Это безымянная функция.
// объявленные переменные станут свойствами объекта вызова, тем самым 
// исключается вероятность конфликтов с глобальным пространством имен.
})(); // конец функционального литерала и его вызов.

arguments.callee();ссылающееся на исполняемую в данный момент функцию

Функции конструкторы
За оператором  new должно быть указано имя функции конструктора. Оператор создает новый пустой объект без каких либо свойств, После создания пустого объекта оператор new устанавливает в этом объекте ссылку на прототип, а затем вызывает функцию, передавая ей только что созданный объект в виде значения ключевого слова this. Прототипом объекта является значение свойства  prototype функции конструктора Rectangle.prototype.area. Любые свойства, добавленные к прототипу, автоматически становятся свойствами объектов, инициализируемых конструктором, объект prototype наследует свойства от  Object.prototype. наследование свойств происходит только при чтении значений свойств, но не при их записи.

function Rectangle(w, h) {
    this.width = w; //открытые свойства
    this.height = h;
    this.area = function( ) { return this.width * this.height; }
}

function Rectangle(w, h) {
    this.getWidth = function() { return w; } //закрытые свойства
    this.getHeight = function() { return h; }
}

поиск свойства по прототипам
Rectangle  ->  Rectangle.prototype -> Object.prototype

наследование
PositionedRectangle.prototype = new Rectangle(); // наследует свойства обьекта Rectangle
PositionedRectangle.prototype.constructor = PositionedRectangle; // заменяем конструктор

PositionedRectangle.prototype.superclass = Rectangle; ссылка на конструктор надкласса
function PositionedRectangle(x, y, w, h) {
    this.superclass(w,h);
    this.x = x;
    this.y = y;
}

свойство prototype
Rectangle.prototype.area = function() { return this.width * this.height; }

cтатическое свойство
Rectangle.PI = 3.14159;

статический метод
Rectangle.AREA = function(x) { return x*x; };

Свойство constructor
var d = new Date( );
d.constructor == Date; // Равно true
if ((typeof o == "object") && (o.constructor == Date))
if ((typeof o == "object") && (o instanceof Date))
if (!a) a = []; -  a = a || [];

function check(args) {// массив аргументов
    var actual = args.length;          // Фактическое число аргументов
    var expected = args.callee.length; // Ожидаемое число аргументов

Массивы
var arr = []; // Пустой массив (литерал)
var a = new Array( ); // Пустой массив
var a = new Array(10); //определяет длину массива

Обьекты  как пространства имен
var flanagan; // Объявление единственного глобального имени "flanagan"
if (!flanagan) flanagan = {}; // Создается объект, если он еще не определен
flanagan.Class = {}           // Создается пространство имен flanagan.Class
// Теперь пространство имен заполняется вспомогательными методами
flanagan.Class.define = function(data) { /* реализация метода */ };
flanagan.Class.provides = function(o, c) { /* реализация метода */ };

(function() { // Определить анонимную функцию. Отсутствие имени 
              // означает отсутствие глобального символа
    // Тело функции находится здесь
    // Здесь можно без опаски объявлять любые переменные,
    // поскольку это не приведет к созданию глобальных символов.
})( );        // Конец определения функции и ее вызов.


 Определение частного пространства имен с помощью замыкания
// Создать объект пространства имен. 
// Для краткости проверка ошибок отсутствует.
var com;
if (!com) com = {};
if (!com.davidflanagan) com.davidflanagan = {};
com.davidflanagan.Class = {};
// Здесь ничего не создается непосредственно в пространстве имен.
// Вместо этого объявляется и вызывается анонимная функция, которая
// создает замыкание, используемое как частное пространство имен.
// Данная функция экспортирует общедоступные символы из замыкания 
// в объект com.davidflanagan.Class
// Обратите внимание: функция не имеет имени, поэтому не создается
// никаких глобальных символов.
(function( ) { // Начало определения анонимной функции
    // Вложенные функции создают символы внутри замыкания
    function define(data) { counter++; /* тело функции */ }
    function provides(o, c) { /* тело функции */ }
    // Локальные переменные – это символы, расположенные внутри замыкания.
    // Этот символ останется частным и будет доступен только внутри замыкания
    var counter = 0;
    // Эта функция может обращаться к переменной с помощью простого имени
    // и не пользоваться полным именем, определяющим пространство имен
    function getCounter( ) { return counter; }
    // Теперь, когда внутри замыкания были определены свойства,
    // которые должны оставаться частными, можно экспортировать символы,
    // доступные во внешнем пространстве имен
    var ns = com.davidflanagan.Class;
    ns.define = define;
    ns.provides = provides;



### DOM_BOM
```
    браузер скачивает по сети текст, создает из него дом структуры которые затем отрисовываются.

    Объектная модель браузера (BOM)
      (BOM) – это объекты для работы с чем угодно, кроме документа. (navigator, location)

    document.addEventListener('DOMContentLoaded', ...); - когда построен дом страници, не ждет картинок, CSS

    псевдоэлементы - задаются и изменяются только через каскад css
```
### Объектная модель документа (DOM)
      Во время загрузки браузер читает документ и тут же строит из него DOM,
      по мере получения информации достраивая новые и новые узлы, и тут же отображая их.
      Когда браузер читает HTML и создаёт DOM-модель, то он создаёт свойства для всех стандартных атрибутов.
      DOM-модель – это внутреннее представление HTML-страницы в виде DOM-узлов.
      HTML-атрибуты и DOM-свойства обычно, но не всегда соответствуют друг другу.
      Для нестандартных атрибутов DOM-свойство не создаётся.
      Стандартные свойства и атрибуты синхронизируются: установка атрибута автоматически ставит свойство DOM.
        Некоторые свойства синхронизируются в обе стороны.  Чаще синхронизация – односторонняя: свойство зависит от атрибута, но не наоборот.
      Все элементы страницы, включая теги, текст, комментарии, являются узлами DOM.
      DOM-узлы – обычные JavaScript-объекты. Их классы заданы в прототипном стиле.
      различие между DOM-узлами – разные узлы являются объектами различных классов.
      Нестандартные (пользовательские) свойства и методы видны только в JavaScript не влияют на отображение тега.

      --для более короткого и понятного кода старайтесь везде использовать свойства, а атрибуты – только там, где это действительно нужно.

        1.Когда нужно кросс-браузерно получить нестандартный HTML-атрибут.
        2.Когда нужно получить «оригинальное значение» стандартного HTML-атрибута, например, <input value="...">.
        3.Когда нужно получить список всех атрибутов, включая пользовательские. Для этого используется коллекция attributes.

    12 типов узлов, но на практике мы работаем с четырьмя из них:
      1.Документ – точка входа в DOM.
        2.Элементы – основные строительные блоки, Теги образуют узлы-элементы (element node).                 ELEMENT_NODE = 1;
        3.Текстовые узлы – содержат, собственно, текст.                                                       TEXT_NODE = 3;
      4.Комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна из JS.   COMMENT_NODE = 8;


### доступ к атрибутам

      Эти методы работают со значением, которое находится в HTML.

      elem.hasAttribute(name) – проверяет наличие атрибута
      elem.getAttribute(name) – получает значение атрибута, input.value = содержит введенное значение
      elem.setAttribute(name, value) – устанавливает атрибут
      elem.removeAttribute(name) – удаляет атрибут
      elem.attributes.attr.value или (elem.attributes[0]) - содержит псевдо-массив объектов типа Attr

      Атрибуту "class" соответствует свойство className.

      elem.classList – псевдо-массив для работы с классами. (живая коллекция, содержит ссылку на нее);
      elem.classList.contains("class") – возвращает true/false, в зависимости от того, есть ли у элемента класс class.
      elem.classList.add/remove("class") – добавляет/удаляет класс class
      elem.classList.toggle("class") – если класса class нет, добавляет его, если есть – удаляет.


      Атрибуты в отличии от свойств - Всегда являются строками, Их имя нечувствительно к регистру (ведь это HTML), Видны в innerHTML

      -- Не стандарьные атрибуты
        Атрибуты, название которых начинается с data-, можно прочитать через dataset.
        <div id="elem" data-about="Elephant">
          elem.dataset.about - получить/изменить значение атрибута через свойство.

        <div class="order" order-state="new">
          div.setAttribute('order-state', 'canceled');
          значение атрибута – произвольная строка, значение класса – это «есть» или «нет», поэтому естественно,
          что атрибуты «мощнее» и бывают удобнее классов как в JS так и в CSS.

### свойства узлов

      nodeType
          Тип узла.
      tagName
          (для элементов) тег.
      nodeName
          для не-элементов обычно содержит строку с типом узла, для элементов равно tagName.
      --содержимое элементов
      innerHTML
          HTML-содержимое элемента в виде строки. В innerHTML можно и читать и писать.(Если в innerHTML есть тег script – он не будет выполнен.)
      outerHTML
          создает новый элемент, заменит след children, возвращает элем след за ним.

      --содержимое текстовых узлов
      data/(nodeValue не используем)
          для всех узлов кроме элементов, равно содержимому узла, доступно на чтение и запись.
      textContent
          возвращает конкатенацию всех текстовых узлов внутри elem, возможность записать текст в элемент, причём именно как текст!
          (нестандартное свойство innerText, не используем).
      hidden
          видим или невидим узел, атрибут и свойство для этого: hidden.  в CSS, свойства display или visibility.

          elem.style.dispaly = 'none'; //удаляется из дерева рендеренга, не сохраняет геометрию (размеры)
          elem.style.visibility = 'hidden'; //находдится в дереве рендеренга, сохраняет геометрию (размеры)

          отобразить elem.style.dispaly = '';

          через css elem.classList.toggle('hidden');

          удалить из док document.body.removeChild(elem)


      При генерации DOM браузер самостоятельно орабатывает ошибки в документе, закрывает теги и так далее.



### Навигация по узлам

        <HTML> = document.documentElement (ссылка на элемент)
        <HEAD> = document.head (в соврем браузерах)
        <BODY> = document.body (ссылка на элемент)
        Нельзя получить доступ к элементу, которого еще не существует в момент выполнения скрипта.
        В частности, если скрипт находится в <head>, то в нём недоступен document.body.
        В мире DOM в качестве значения, обозначающего «нет такого элемента» или «узел не найден», используется null.

        Дочерние элементы (или дети) – элементы, которые лежат непосредственно внутри данного. Например, внутри <HTML> обычно лежат <HEAD> и <BODY>.

        Потомки – все элементы, которые лежат внутри данного, вместе с их детьми, детьми их детей и так далее. То есть, всё поддерево DOM.


    -- навигация по всем узлам (узлам-элементам текстовым узлы и узлам-комментариям)
        в childNodes сосуществуют текстовые узлы, узлы-элементы,/ узлы-комментарии
        elem.childNodes - (псевдомассив как arguments) все дочерние элементы body.
        elem.hasChildNodes - наличие дочерних элементов.
        elem.firstChild - первый дочерний элемент body.      elem.childNodes[0] === elem.firstChild
        eles.lastChild - последний дочерний элемент body.    elem.childNodes[elem.childNodes.length - 1] === elem.lastChild
        elem.previousSibling, nextSibling - доступ к элементам слева и справа данного
        elem.parentNode - доступ к родителю.

    -- Навигация только по элементам
        elem.children – только дочерние узлы-элементы, то есть соответствующие тегам.
        elem.firstElementChild, lastElementChild – соответственно, первый и последний дети-элементы.
        elem.previousElementSibling, nextElementSibling – соседи-элементы.
        elem.parentElement – родитель-элемент.

        elem.children[0] === elem.firstElementChild
        elem.children[elem.children.length - 1] === elem.lastElementChild

    отличие parentNode от parentElementparentNode
      alert( document.documentElement.parentNode ); // document
      alert( document.documentElement.parentElement ); // null

    -- навигация по формам, таблицам.
        document.forms.myform - доступ к форме по имени
        document.forms.mytable.elements.myinput - доступ к полю по имени
        table.rows - псевдомассив строк
        table.rows[0].cells - псевдомассив ячеек



### поиск элементов (Есть 6 основных методов поиска элементов DOM)

        в 95% ситуаций достаточно querySelector/querySelectorAll. Хотя более специализированные методы getElement* работают чуть быстрее

        --Внутреннее устройство поисковых методов

        getElementsBy* – живые запросы! При изменении документа – изменяется и результат запроса.
        поиск выполняется только при обращении к элементам коллекции или к её длине.

        elem.querySelector/All- Последние результаты поиска сохраняются в кеше. Но это до тех пор, пока документ как-нибудь не изменится.

        --поиск только в контексте document (возвращает только элементы)
          document.getElementById("list") или через переменную list, getElementById
            (живая колекция)document.getElementsByName(name) - возвращает список элементов с атрибутом name.(используется редко)

        живая колекция - хранит живой поисковый запрос, который выполняется при обращении к элементам колекции.
          при изменении документа, поиск структура сбрасывается, если в этот узеле есть изменения.(колекция не держит док в памяти)

        --поиск внутри элементов (возвращает только элементы)
          (живая колекция)elem.getElementsByTagName(tag) - возвращает список элементов, ('*' вместо тега, получить всех потомков)
          (живая колекция)elem.getElementsByClassName(className) возвращает коллекцию элементов с классом className (даже если у него несколько классов)
          elem.querySelectorAll(css) возвращает все элементы внутри elem, удовлетворяющие CSS-селектору css.(делает полный обход документа)
          (хранит старую колекцию после изменения или удаления из дом)
          elem.querySelector(css) возвращает не все, а только первый элемент, соответствующий CSS-селектору css.
          elem.closest(css) для поиска ближайшего родителя. Сам элемент тоже включается в поиск.

        --при переборе элементов
        elem.matches(css) проверяет, удовлетворяет ли elem селектору css, возвращает true либо false.

        -- Xpath (язык запросов) обычно используется в XML. также HTML, кроме IE<9 (используется редко)


### Методы для создания узлов:

        document.createElement(tag) – создает элемент
        document.createTextNode(value) – создает текстовый узел
        elem.cloneNode(deep) – клонирует элемент, если deep == true, то со всеми потомками, если false – без потомков.

        Вставка и удаление узлов:
        при вставке узла происходят разные внутренние события и обновления внутренних структур данных, скрытые от наших глаз.

        parent.appendChild(elem)
        parent.insertBefore(elem, nextSibling) nextSibling - перед кем вставить
        parent.removeChild(elem)
        parent.replaceChild(newElem, elem)
        Все эти методы возвращают elem.

        innerHTML += удаляет все содержимое, ставит новое (изменяя внутренние структуры).
        insertAdjacentHTML позволяет вставлять произвольный HTML в любое место документа, в том числе и между узлами!
        elem.insertAdjacentElement(where, newElem) – вставляет в произвольное место не строку HTML, а элемент newElem.
        elem.insertAdjacentText(where, text) – создаёт текстовый узел из строки text и вставляет его в указанное место относительно elem.

        node.append(...nodes) – вставляет nodes в конец node,
        node.prepend(...nodes) – вставляет nodes в начало node,
        node.after(...nodes) – вставляет nodes после узла node,
        node.before(...nodes) – вставляет nodes перед узлом node,
        node.replaceWith(...nodes) – вставляет nodes вместо node.


###  <script> document.write('') </script> используется там где не подходят методы дом

        <script> document.write('<script> document.write("<li>asd</li>") <\/script>') </script>

        альтернатива

        // браузер загрузит скрипт, и выполнит его, (асинхр)не блокирует отрисовку страници в отличии от document.write
        var script = document.createElement('script');
          script.src = '';
          document.body.appendChild('script');


        Методы document.write пишут напрямую в текст в документ, до создания DOM,
        поэтому они могут записать в документ все, что угодно, любые стили и незакрытые теги.
        Метод document.write вставляет любой текст на страницу «как есть»
        Запуск document.write после загрузки приведёт к очистке документа.

        document.close();

        Загрузка динамического скрипта блокирует отрисовку всей страниц, и будет ждать его загрузки.
        желательно подключать внешние скрипты, используя вставку скрипта через DOM или async/defer.

###  навигация по элементам в консоли

        $0 - теккущий элемент, выбранный во вкладке Elements
        $1 - предыдущий выбранный эл, и так далее.
        inspect($1) - переходит на элемент.
        $$("div.my") – ищет все элементы в DOM по данному CSS-селектору
        $("div.my") – ищет первый элемент в DOM по данному CSS-селектору.


###  стили элемента
        Свойство style содержит лишь тот стиль, который указан в атрибуте элемента, без учёта каскада CSS.

        element.style возвращает объект, который дает доступ к стилю элемента на чтение и запись.
          Чтобы сбросить elem.style.width="". При сбросе свойства style стиль будет взят из CSS.
          Свойство style нужно использовать лишь там, где классы не подходят, например
            если точное значение цвета/отступа/высоты вычисляется в JavaScript.

        element.style.cssText = "..." позволяет поставить стиль целиком в виде строки.(осуществляет полную перезапись style.)

        getComputedStyle(elem) - свойство стиля с учётом CSS-каскада и браузерных стилей по умолчанию
          При обращении к сокращенному: padding, margin, border – правильный результат не гарантируется.
          нужно указать точное свойство. Например: paddingLeft, marginTop, borderLeftWidth.
        В IE8- нет getComputedStyle, но у элементов есть свойство currentStyle

        Вычисленное (computed) и окончательное (resolved) значения
          В CSS есть две концепции:

          Вычисленное (computed) значение – это то, которое получено после применения всех правил CSS и CSS-наследования.
              Например, width: auto или font-size: 125%.
          Окончательное (resolved) значение – непосредственно применяемое к элементу.
              При этом все размеры приводятся к пикселям, например width: 212px или font-size: 16px. В некоторых браузерах пиксели могут быть дробными.
          Когда-то getComputedStyle

###  проверка на вложеность, порядок расположения узлов
        nodeA.contains(nodeB) - является ли один узел предком другого.
        nodeA.compareDocumentPosition(nodeB); - порядок расположения узлов.
        Для IE8 нужен полифилл для compareDocumentPosition.


###  iframe
        в каждом iframe свой независимый документ
        если фреймы на разных доменах, (как независимые окна браузера)мы не можем между ними общяться.

        iframe.contentWindow.document - у каждого окна свой документ.

        X-Frame-Options - запрет показывать в iframe. (DANY - всем) (SAMEORIGIN - разрешает если страница на том же домене)

###  Полифиллы
        «Полифилл» (англ. polyfill) – это библиотека, которая добавляет в старые браузеры поддержку возможностей,
            которые в современных браузерах являются встроенными.

          Создаётся элемент, который его, в теории, должен поддерживать.
          Соответствующее свойство сравнивается с undefined.
          Если его нет – модифицируется прототип, обычно это Element.prototype – в него дописываются новые геттеры(Object.defineProperty) и функции.

        Полифиллы хороши тем, что мы просто подключаем их и используем везде современный DOM/JS,
        а когда старые браузеры окончательно отомрут – просто выкинем полифилл, без изменения кода.


### живая коллекция пример
        <ul id="menu">
          <li>Главная страница</li>
          <li>Форум</li>
          <li>Магазин</li>
        </ul>

        <script>
          var lis1 = document.body.getElementsByTagName('li');

          var menu = document.getElementById('menu');
          var lis2 = menu.getElementsByTagName('li');

          console.log(lis1);
          console.log(lis2);

          document.body.innerHTML = '';

          console.log('после удаления');
          console.log(lis1);
          console.log(lis2);
        </script>



